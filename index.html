<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RailPlot Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 16px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 8px;
        }
        .subtitle {
            text-align: center;
            color: #666;
            font-size: 14px;
            margin-bottom: 24px;
        }
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            background: #f8f9ff;
            margin-bottom: 20px;
        }
        .upload-area:hover { border-color: #764ba2; background: #f0f2ff; }
        .upload-area.dragover { border-color: #4CAF50; background: #e8f5e9; }
        input[type="file"] { display: none; }
        .btn {
            padding: 12px 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            margin: 4px;
        }
        .btn:hover { transform: translateY(-2px); }
        .controls {
            margin: 20px 0;
            padding: 16px;
            background: #f8f9ff;
            border-radius: 8px;
            display: none;
        }
        .control-group {
            margin: 12px 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        label { font-weight: 600; min-width: 80px; }
        input[type="range"] { flex: 1; }
        input[type="checkbox"] { 
            width: 20px; 
            height: 20px; 
            cursor: pointer; 
        }
        #canvas-container {
            margin-top: 20px;
            overflow: hidden;
            border-radius: 12px;
            background: white;
            display: none;
            min-height: 600px;
            touch-action: none;
            position: relative;
        }
        canvas { 
            display: block; 
            cursor: grab;
            position: absolute;
            top: 0;
            left: 0;
        }
        canvas:active { cursor: grabbing; }
        #status {
            margin: 16px 0;
            padding: 12px;
            border-radius: 8px;
            display: none;
        }
        .success { background: #e8f5e9; color: #2e7d32; }
        .error { background: #ffebee; color: #c62828; }
        .loading { background: #e3f2fd; color: #1976d2; }
    </style>
</head>
<body>
    <div class="container">
        <h1>RailPlot Viewer</h1>
        <p class="subtitle">PlaDia/RailPlotÂΩ¢ÂºèCSV„Éì„É•„Éº„Ç¢„Éº</p>
        
        <div class="upload-area" id="uploadArea">
            <div style="font-size: 48px; margin-bottom: 16px;">üìÅ</div>
            <p style="font-size: 18px; font-weight: 600; margin-bottom: 12px;">
                CSV„Éï„Ç°„Ç§„É´„Çí„Éâ„É≠„ÉÉ„Éó„Åæ„Åü„ÅØ„ÇØ„É™„ÉÉ„ÇØ
            </p>
            <button class="btn" onclick="document.getElementById('fileInput').click()">
                „Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû
            </button>
            <input type="file" id="fileInput" accept=".csv">
            <p style="color: #666; font-size: 14px; margin-top: 12px;">
                RailPlotÂΩ¢Âºè„ÅÆ„É¨„Ç§„Ç¢„Ç¶„ÉàCSV„Éï„Ç°„Ç§„É´
            </p>
        </div>

        <div class="controls" id="controls">
            <div class="control-group">
                <label>„Ç∫„Éº„É†:</label>
                <input type="range" id="zoomSlider" min="0.1" max="3" step="0.05" value="1">
                <span id="zoomValue">100%</span>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="showDesksCheckbox" checked onchange="toggleDesks()">
                    Êú∫„ÇíË°®Á§∫
                </label>
            </div>
            <div class="control-group">
                <button class="btn" onclick="resetView()">Ë°®Á§∫„É™„Çª„ÉÉ„Éà</button>
                <button class="btn" onclick="exportImage()">ÁîªÂÉè„Å®„Åó„Å¶‰øùÂ≠ò</button>
            </div>
        </div>

        <div id="status"></div>
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <script>
        const SCALE_FACTOR = 0.05;
        const DESK_SCALE_FACTOR = SCALE_FACTOR * 20;
        
        const LAYER_DESK = 0;
        const LAYER_BELOW = 1;
        const LAYER_NORMAL = 2;
        const LAYER_ABOVE = 3;
        
        const ABOVE_LAYER_PARTS = new Set([
            'big_iron_bridge_red_single',
            'big_iron_bridge_red_double',
            'tunnel',
            'extending_tunnel',
            'garage'
        ]);
        
        const BELOW_LAYER_PARTS = new Set([]);
        
        let layoutParts = [];
        let layoutTexts = [];
        let imageCache = {};
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let lastX = 0, lastY = 0;
        let showDesks = true;
        
        let initialPinchDistance = 0;
        let initialScale = 1;
        let isPinching = false;
        let pinchCenterX = 0;
        let pinchCenterY = 0;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');
        const canvasContainer = document.getElementById('canvas-container');
        const controlsDiv = document.getElementById('controls');
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files[0]) loadLayoutFile(e.dataTransfer.files[0]);
        });
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) loadLayoutFile(e.target.files[0]);
        });
        document.getElementById('zoomSlider').addEventListener('input', (e) => {
            scale = parseFloat(e.target.value);
            document.getElementById('zoomValue').textContent = Math.round(scale * 100) + '%';
            draw();
        });

        function toggleDesks() {
            showDesks = document.getElementById('showDesksCheckbox').checked;
            draw();
        }
        
        function getCanvasLayer(part) {
            if (part.category === 'desk') {
                return LAYER_DESK;
            }
            if (ABOVE_LAYER_PARTS.has(part.partId)) {
                return LAYER_ABOVE;
            }
            if (BELOW_LAYER_PARTS.has(part.partId)) {
                return LAYER_BELOW;
            }
            return LAYER_NORMAL;
        }

        async function loadLayoutFile(file) {
            if (!file.name.endsWith('.csv')) {
                showStatus('CSV„Éï„Ç°„Ç§„É´„ÇíÈÅ∏Êäû„Åó„Å¶„Åè„Å†„Åï„ÅÑ', 'error');
                return;
            }

            showStatus('Ë™≠„ÅøËæº„Åø‰∏≠...', 'loading');
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    await parseLayoutCSV(e.target.result);
                    
                    if (layoutParts.length === 0 && layoutTexts.length === 0) {
                        showStatus('„Ç®„É©„Éº: „Éë„Éº„ÉÑ„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì', 'error');
                        return;
                    }
                    
                    await loadImages();
                    setupCanvas();
                    fitToScreen();
                    draw();
                    
                    canvasContainer.style.display = 'block';
                    controlsDiv.style.display = 'block';
                    showStatus(`‚úÖ ${file.name} „ÇíË™≠„ÅøËæº„Åø„Åæ„Åó„ÅüÔºà${layoutParts.length}„Éë„Éº„ÉÑ, ${layoutTexts.length}„ÉÜ„Ç≠„Çπ„ÉàÔºâ`, 'success');
                } catch (error) {
                    showStatus('„Ç®„É©„Éº: ' + error.message, 'error');
                    console.error(error);
                }
            };
            reader.readAsText(file, 'UTF-8');
        }

        async function parseLayoutCSV(csvText) {
            layoutParts = [];
            layoutTexts = [];
            const lines = csvText.split('\n');
            
            for (let i = 2; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const parts = line.split(',');
                if (parts.length < 9) continue;
                
                const category = parts[0];
                
                // „ÉÜ„Ç≠„Çπ„Éà„ÅÆÂ†¥Âêà
                if (category === 'text') {
                    const text = parts[1] || '';
                    const x = parseFloat(parts[3]) || 0;
                    const y = parseFloat(parts[4]) || 0;
                    const angle = parseFloat(parts[5]) || 0;
                    const fontSize = parseInt(parts[7]) || 24;
                    const zIndex = parseInt(parts[8]) || 0;
                    
                    layoutTexts.push({ text, x, y, angle, fontSize, zIndex });
                    continue;
                }
                
                const partId = parts[1];
                const x = parseFloat(parts[3]) || 0;
                const y = parseFloat(parts[4]) || 0;
                const angle = parseFloat(parts[5]) || 0;
                const flipped = parts[6] === 'True';
                const zIndex = parseInt(parts[8]) || 0;
                
                const part = { category, partId, x, y, angle, flipped, zIndex };
                part.canvasLayer = getCanvasLayer(part);
                
                layoutParts.push(part);
            }
            
            layoutParts.sort((a, b) => {
                if (a.canvasLayer !== b.canvasLayer) {
                    return a.canvasLayer - b.canvasLayer;
                }
                return a.zIndex - b.zIndex;
            });
            
            console.log('‚úÖ „Éë„Éº„ÉÑÊï∞:', layoutParts.length, '„ÉÜ„Ç≠„Çπ„Éà:', layoutTexts.length);
        }

        async function loadImages() {
            const promises = [];
            const uniqueParts = new Set();
            let loaded = 0, failed = 0;
            
            for (let part of layoutParts) {
                const key = `${part.category}_${part.partId}_${part.flipped}`;
                if (!uniqueParts.has(key) && part.partId) {
                    uniqueParts.add(key);
                    promises.push(
                        loadImage(part.category, part.partId, part.flipped)
                            .then(() => loaded++)
                            .catch(() => failed++)
                    );
                }
            }
            
            await Promise.all(promises);
        }

        async function loadImage(category, partId, flipped) {
            const key = `${category}_${partId}_${flipped}`;
            if (imageCache[key]) return;
            
            // ÁîªÂÉè„Éï„Ç°„Ç§„É´Âêç: flipped=true„Å™„Çâ _inverted.png„ÄÅfalse„Å™„Çâ _1.png
            const filename = flipped ? `${partId}_inverted.png` : `${partId}_1.png`;
            
            let basePath;
            if (partId.includes(':')) {
                const [addonName, actualPartId] = partId.split(':');
                const actualFilename = flipped ? `${actualPartId}_inverted.png` : `${actualPartId}_1.png`;
                basePath = `addon/${addonName}/image/${category}/${actualPartId}/${actualFilename}`;
            } else {
                basePath = `image/${category}/${partId}/${filename}`;
            }
            
            await tryLoadImage(basePath, key);
        }

        function tryLoadImage(path, key) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    imageCache[key] = img;
                    resolve();
                };
                img.onerror = () => {
                    reject();
                };
                img.src = path;
            });
        }

        function setupCanvas() {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            for (let part of layoutParts) {
                const x = part.x * SCALE_FACTOR;
                const y = part.y * SCALE_FACTOR;
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
            
            for (let text of layoutTexts) {
                const x = text.x * SCALE_FACTOR;
                const y = text.y * SCALE_FACTOR;
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
            
            const margin = 100;
            canvas.width = Math.max(1000, maxX - minX + margin * 2);
            canvas.height = Math.max(800, maxY - minY + margin * 2);
            
            offsetX = -minX + margin;
            offsetY = -minY + margin;
        }

        function fitToScreen() {
            const containerWidth = canvasContainer.clientWidth;
            const containerHeight = canvasContainer.clientHeight;
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            const scaleX = containerWidth / canvasWidth;
            const scaleY = containerHeight / canvasHeight;
            scale = Math.min(scaleX, scaleY) * 0.95;
            
            document.getElementById('zoomSlider').value = scale;
            document.getElementById('zoomValue').textContent = Math.round(scale * 100) + '%';
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.scale(scale, scale);
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width / scale, canvas.height / scale);
            
            // „Éë„Éº„ÉÑ„ÇíÊèèÁîª
            for (let part of layoutParts) {
                if (part.category === 'desk' && !showDesks) continue;
                drawPart(part);
            }
            
            // „ÉÜ„Ç≠„Çπ„Éà„ÇíÊèèÁîªÔºàÊúÄÂâçÈù¢Ôºâ
            for (let text of layoutTexts) {
                drawText(text);
            }
            
            ctx.restore();
        }

        function drawPart(part) {
            const key = `${part.category}_${part.partId}_${part.flipped}`;
            const img = imageCache[key];
            
            if (!img) {
                const x = part.x * SCALE_FACTOR + offsetX;
                const y = part.y * SCALE_FACTOR + offsetY;
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(x - 5, y - 5, 10, 10);
                return false;
            }
            
            ctx.save();
            
            const csvX = part.x;
            const csvY = part.y;
            const angle = part.angle;
            
            const imgCenterX = img.width / 2;
            const imgCenterY = img.height / 2;
            
            const partScaleFactor = (part.category === 'desk') ? DESK_SCALE_FACTOR : SCALE_FACTOR;
            
            ctx.translate(csvX * SCALE_FACTOR + offsetX, csvY * SCALE_FACTOR + offsetY);
            ctx.scale(partScaleFactor, partScaleFactor);
            ctx.translate(imgCenterX, imgCenterY);
            ctx.rotate((angle * Math.PI) / 180);
            
            // flipped„ÅÆÂ†¥Âêà„ÅØ_inverted.png„Çí‰Ωø„ÅÜ„ÅÆ„Åß„ÄÅscale(-1,1)„ÅØ‰∏çË¶Å
            
            ctx.translate(-imgCenterX, -imgCenterY);
            
            ctx.globalAlpha = 1.0;
            ctx.drawImage(img, 0, 0);
            
            ctx.restore();
            return true;
        }

        function drawText(textObj) {
            ctx.save();
            
            const x = textObj.x * SCALE_FACTOR + offsetX;
            const y = textObj.y * SCALE_FACTOR + offsetY;
            
            ctx.translate(x, y);
            ctx.rotate((textObj.angle * Math.PI) / 180);
            
            ctx.font = `${textObj.fontSize * SCALE_FACTOR}px sans-serif`;
            ctx.fillStyle = '#000000';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(textObj.text, 0, 0);
            
            ctx.restore();
        }

        canvas.addEventListener('mousedown', startDrag);
        canvas.addEventListener('mousemove', drag);
        canvas.addEventListener('mouseup', endDrag);
        canvas.addEventListener('mouseleave', endDrag);
        
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', handleTouchEnd);

        function handleTouchStart(e) {
            e.preventDefault();
            
            if (e.touches.length === 2) {
                isPinching = true;
                isDragging = false;
                initialPinchDistance = getDistance(e.touches[0], e.touches[1]);
                initialScale = scale;
                
                const rect = canvas.getBoundingClientRect();
                pinchCenterX = ((e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left) / scale;
                pinchCenterY = ((e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top) / scale;
                
            } else if (e.touches.length === 1) {
                if (!isPinching) {
                    const touch = e.touches[0];
                    startDrag({ clientX: touch.clientX, clientY: touch.clientY });
                }
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            
            if (e.touches.length === 2 && isPinching) {
                const currentDistance = getDistance(e.touches[0], e.touches[1]);
                const scaleChange = currentDistance / initialPinchDistance;
                const newScale = Math.max(0.1, Math.min(3, initialScale * scaleChange));
                
                const rect = canvas.getBoundingClientRect();
                const currentCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
                const currentCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
                
                const targetCenterX = currentCenterX / newScale;
                const targetCenterY = currentCenterY / newScale;
                
                offsetX += (targetCenterX - pinchCenterX);
                offsetY += (targetCenterY - pinchCenterY);
                
                pinchCenterX = targetCenterX;
                pinchCenterY = targetCenterY;
                
                scale = newScale;
                
                document.getElementById('zoomSlider').value = scale;
                document.getElementById('zoomValue').textContent = Math.round(scale * 100) + '%';
                
                draw();
                
            } else if (e.touches.length === 1 && !isPinching) {
                const touch = e.touches[0];
                drag({ clientX: touch.clientX, clientY: touch.clientY });
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            
            if (e.touches.length < 2) {
                isPinching = false;
                initialPinchDistance = 0;
            }
            
            if (e.touches.length === 0) {
                endDrag();
            }
        }

        function getDistance(touch1, touch2) {
            const dx = touch2.clientX - touch1.clientX;
            const dy = touch2.clientY - touch1.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function startDrag(e) {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        }
        
        function drag(e) {
            if (!isDragging) return;
            
            offsetX += (e.clientX - lastX) / scale;
            offsetY += (e.clientY - lastY) / scale;
            
            lastX = e.clientX;
            lastY = e.clientY;
            
            draw();
        }
        
        function endDrag() {
            isDragging = false;
        }
        
        function resetView() {
            setupCanvas();
            fitToScreen();
            draw();
        }
        
        function exportImage() {
            const link = document.createElement('a');
            link.download = 'railplot-layout.png';
            link.href = canvas.toDataURL();
            link.click();
        }
        
        function showStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = type;
            statusDiv.style.display = 'block';
            if (type !== 'loading') {
                setTimeout(() => statusDiv.style.display = 'none', 5000);
            }
        }
    </script>
</body>
</html>
