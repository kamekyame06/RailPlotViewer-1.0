<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RailPlot Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 16px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 8px;
        }
        .subtitle {
            text-align: center;
            color: #666;
            font-size: 14px;
            margin-bottom: 24px;
        }
        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 12px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            background: #f8f9ff;
            margin-bottom: 20px;
        }
        .upload-area:hover { border-color: #764ba2; background: #f0f2ff; }
        .upload-area.dragover { border-color: #4CAF50; background: #e8f5e9; }
        input[type="file"] { display: none; }
        .btn {
            padding: 12px 28px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 600;
            margin: 4px;
        }
        .btn:hover { transform: translateY(-2px); }
        .controls {
            margin: 20px 0;
            padding: 16px;
            background: #f8f9ff;
            border-radius: 8px;
            display: none;
        }
        .control-group {
            margin: 12px 0;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        label { font-weight: 600; min-width: 80px; }
        input[type="range"] { flex: 1; }
        input[type="checkbox"] { 
            width: 20px; 
            height: 20px; 
            cursor: pointer; 
        }
        #canvas-container {
            margin-top: 20px;
            overflow: hidden;
            border-radius: 12px;
            background: white;
            display: none;
            min-height: 600px;
            touch-action: none;
            position: relative;
        }
        canvas { 
            display: block; 
            cursor: grab;
            position: absolute;
            top: 0;
            left: 0;
        }
        canvas:active { cursor: grabbing; }
        #status {
            margin: 16px 0;
            padding: 12px;
            border-radius: 8px;
            display: none;
        }
        .success { background: #e8f5e9; color: #2e7d32; }
        .error { background: #ffebee; color: #c62828; }
        .loading { background: #e3f2fd; color: #1976d2; }
    </style>
</head>
<body>
    <div class="container">
        <h1>RailPlot Viewer</h1>
        <p class="subtitle">PlaDia/RailPlotå½¢å¼CSVãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ¼</p>
        
        <div class="upload-area" id="uploadArea">
            <div style="font-size: 48px; margin-bottom: 16px;">ğŸ“</div>
            <p style="font-size: 18px; font-weight: 600; margin-bottom: 12px;">
                CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ‰ãƒ­ãƒƒãƒ—ã¾ãŸã¯ã‚¯ãƒªãƒƒã‚¯
            </p>
            <button class="btn" onclick="document.getElementById('fileInput').click()">
                ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ
            </button>
            <input type="file" id="fileInput" accept=".csv">
            <p style="color: #666; font-size: 14px; margin-top: 12px;">
                RailPlotå½¢å¼ã®ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆCSVãƒ•ã‚¡ã‚¤ãƒ«
            </p>
        </div>

        <div class="controls" id="controls">
            <div class="control-group">
                <label>ã‚ºãƒ¼ãƒ :</label>
                <input type="range" id="zoomSlider" min="0.1" max="3" step="0.05" value="1">
                <span id="zoomValue">100%</span>
            </div>
            <div class="control-group">
                <label>
                    <input type="checkbox" id="showDesksCheckbox" checked onchange="toggleDesks()">
                    æœºã‚’è¡¨ç¤º
                </label>
            </div>
            <div class="control-group">
                <button class="btn" onclick="resetView()">è¡¨ç¤ºãƒªã‚»ãƒƒãƒˆ</button>
                <button class="btn" onclick="exportImage()">ç”»åƒã¨ã—ã¦ä¿å­˜</button>
            </div>
        </div>

        <div id="status"></div>
        <div id="canvas-container">
            <canvas id="canvas"></canvas>
        </div>
    </div>

    <script>
        const SCALE_FACTOR = 0.05;
        const DESK_SCALE_FACTOR = SCALE_FACTOR * 20;
        
        let layoutParts = [];
        let imageCache = {};
        let scale = 1;
        let offsetX = 0;
        let offsetY = 0;
        let isDragging = false;
        let lastX = 0, lastY = 0;
        let showDesks = true;
        
        // ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ç”¨
        let initialPinchDistance = 0;
        let initialScale = 1;
        let isPinching = false;
        let pinchCenterX = 0;
        let pinchCenterY = 0;

        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const statusDiv = document.getElementById('status');
        const canvasContainer = document.getElementById('canvas-container');
        const controlsDiv = document.getElementById('controls');
        const uploadArea = document.getElementById('uploadArea');
        const fileInput = document.getElementById('fileInput');

        uploadArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadArea.classList.add('dragover');
        });
        uploadArea.addEventListener('dragleave', () => uploadArea.classList.remove('dragover'));
        uploadArea.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadArea.classList.remove('dragover');
            if (e.dataTransfer.files[0]) loadLayoutFile(e.dataTransfer.files[0]);
        });
        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) loadLayoutFile(e.target.files[0]);
        });
        document.getElementById('zoomSlider').addEventListener('input', (e) => {
            scale = parseFloat(e.target.value);
            document.getElementById('zoomValue').textContent = Math.round(scale * 100) + '%';
            draw();
        });

        function toggleDesks() {
            showDesks = document.getElementById('showDesksCheckbox').checked;
            draw();
        }

        async function loadLayoutFile(file) {
            if (!file.name.endsWith('.csv')) {
                showStatus('CSVãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠã—ã¦ãã ã•ã„', 'error');
                return;
            }

            showStatus('èª­ã¿è¾¼ã¿ä¸­...', 'loading');
            
            const reader = new FileReader();
            reader.onload = async (e) => {
                try {
                    await parseLayoutCSV(e.target.result);
                    
                    if (layoutParts.length === 0) {
                        showStatus('ã‚¨ãƒ©ãƒ¼: ãƒ‘ãƒ¼ãƒ„ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“', 'error');
                        return;
                    }
                    
                    await loadImages();
                    setupCanvas();
                    fitToScreen(); // ç”»é¢ã«åã‚ã‚‹
                    draw();
                    
                    canvasContainer.style.display = 'block';
                    controlsDiv.style.display = 'block';
                    showStatus(`âœ… ${file.name} ã‚’èª­ã¿è¾¼ã¿ã¾ã—ãŸï¼ˆ${layoutParts.length}ãƒ‘ãƒ¼ãƒ„ï¼‰`, 'success');
                } catch (error) {
                    showStatus('ã‚¨ãƒ©ãƒ¼: ' + error.message, 'error');
                    console.error(error);
                }
            };
            reader.readAsText(file, 'UTF-8');
        }

        async function parseLayoutCSV(csvText) {
            layoutParts = [];
            const lines = csvText.split('\n');
            
            for (let i = 2; i < lines.length; i++) {
                const line = lines[i].trim();
                if (!line) continue;
                
                const parts = line.split(',');
                if (parts.length < 9) continue;
                
                const category = parts[0];
                const partId = parts[1];
                const x = parseFloat(parts[3]) || 0;
                const y = parseFloat(parts[4]) || 0;
                const angle = parseFloat(parts[5]) || 0;
                const flipped = parts[6] === 'True';
                const zOrder = parseInt(parts[8]) || 0;
                
                if (category === 'text') continue;
                
                layoutParts.push({ category, partId, x, y, angle, flipped, zOrder });
            }
            
            layoutParts.sort((a, b) => a.zOrder - b.zOrder);
        }

        async function loadImages() {
            const promises = [];
            const uniqueParts = new Set();
            let loaded = 0, failed = 0;
            
            for (let part of layoutParts) {
                const key = `${part.category}_${part.partId}`;
                if (!uniqueParts.has(key) && part.partId) {
                    uniqueParts.add(key);
                    promises.push(
                        loadImage(part.category, part.partId)
                            .then(() => loaded++)
                            .catch(() => failed++)
                    );
                }
            }
            
            await Promise.all(promises);
        }

        async function loadImage(category, partId) {
            const key = `${category}_${partId}`;
            if (imageCache[key]) return;
            
            if (partId.includes(':')) {
                const [addonName, actualPartId] = partId.split(':');
                const path = `addon/${addonName}/image/${category}/${actualPartId}/${actualPartId}_1.png`;
                await tryLoadImage(path, key);
            } else {
                const path = `image/${category}/${partId}/${partId}_1.png`;
                await tryLoadImage(path, key);
            }
        }

        function tryLoadImage(path, key) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => {
                    imageCache[key] = img;
                    resolve();
                };
                img.onerror = () => {
                    reject();
                };
                img.src = path;
            });
        }

        function setupCanvas() {
            if (layoutParts.length === 0) return;
            
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            
            for (let part of layoutParts) {
                const x = part.x * SCALE_FACTOR;
                const y = part.y * SCALE_FACTOR;
                minX = Math.min(minX, x);
                maxX = Math.max(maxX, x);
                minY = Math.min(minY, y);
                maxY = Math.max(maxY, y);
            }
            
            const margin = 100;
            canvas.width = Math.max(1000, maxX - minX + margin * 2);
            canvas.height = Math.max(800, maxY - minY + margin * 2);
            
            offsetX = -minX + margin;
            offsetY = -minY + margin;
        }

        function fitToScreen() {
            // ã‚³ãƒ³ãƒ†ãƒŠã®ã‚µã‚¤ã‚º
            const containerWidth = canvasContainer.clientWidth;
            const containerHeight = canvasContainer.clientHeight;
            
            // Canvasã®ã‚µã‚¤ã‚º
            const canvasWidth = canvas.width;
            const canvasHeight = canvas.height;
            
            // ç”»é¢ã«åã¾ã‚‹ã‚¹ã‚±ãƒ¼ãƒ«ã‚’è¨ˆç®—
            const scaleX = containerWidth / canvasWidth;
            const scaleY = containerHeight / canvasHeight;
            scale = Math.min(scaleX, scaleY) * 0.95; // 95%ã§å°‘ã—ä½™ç™½ã‚’æŒãŸã›ã‚‹
            
            // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚’æ›´æ–°
            document.getElementById('zoomSlider').value = scale;
            document.getElementById('zoomValue').textContent = Math.round(scale * 100) + '%';
            
            console.log('ğŸ¯ åˆæœŸã‚¹ã‚±ãƒ¼ãƒ«:', scale.toFixed(2));
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            ctx.scale(scale, scale);
            
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, canvas.width / scale, canvas.height / scale);
            
            let drawn = 0;
            
            if (showDesks) {
                for (let part of layoutParts) {
                    if (part.category === 'desk') {
                        if (drawPart(part)) drawn++;
                    }
                }
            }
            
            for (let part of layoutParts) {
                if (part.category !== 'desk') {
                    if (drawPart(part)) drawn++;
                }
            }
            
            ctx.restore();
        }

        function drawPart(part) {
            const key = `${part.category}_${part.partId}`;
            const img = imageCache[key];
            
            if (!img) {
                const x = part.x * SCALE_FACTOR + offsetX;
                const y = part.y * SCALE_FACTOR + offsetY;
                ctx.fillStyle = '#ff6b6b';
                ctx.fillRect(x - 5, y - 5, 10, 10);
                return false;
            }
            
            ctx.save();
            
            const csvX = part.x;
            const csvY = part.y;
            const angle = part.angle;
            const flipped = part.flipped;
            
            const imgCenterX = img.width / 2;
            const imgCenterY = img.height / 2;
            
            const partScaleFactor = (part.category === 'desk') ? DESK_SCALE_FACTOR : SCALE_FACTOR;
            
            ctx.translate(csvX * SCALE_FACTOR + offsetX, csvY * SCALE_FACTOR + offsetY);
            ctx.scale(partScaleFactor, partScaleFactor);
            ctx.translate(imgCenterX, imgCenterY);
            ctx.rotate((angle * Math.PI) / 180);
            
            if (flipped) {
                ctx.scale(-1, 1);
            }
            
            ctx.translate(-imgCenterX, -imgCenterY);
            
            ctx.globalAlpha = 1.0;
            ctx.drawImage(img, 0, 0);
            
            ctx.restore();
            return true;
        }

        // ãƒã‚¦ã‚¹æ“ä½œ
        canvas.addEventListener('mousedown', startDrag);
        canvas.addEventListener('mousemove', drag);
        canvas.addEventListener('mouseup', endDrag);
        canvas.addEventListener('mouseleave', endDrag);
        
        // ã‚¿ãƒƒãƒæ“ä½œ
        canvas.addEventListener('touchstart', handleTouchStart);
        canvas.addEventListener('touchmove', handleTouchMove);
        canvas.addEventListener('touchend', handleTouchEnd);

        function handleTouchStart(e) {
            e.preventDefault();
            
            if (e.touches.length === 2) {
                // 2æœ¬æŒ‡ â†’ ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ é–‹å§‹
                isPinching = true;
                isDragging = false;
                initialPinchDistance = getDistance(e.touches[0], e.touches[1]);
                initialScale = scale;
                
                // ãƒ”ãƒ³ãƒã®ä¸­å¿ƒç‚¹ã‚’è¨ˆç®—ï¼ˆCanvasä¸Šã®åº§æ¨™ï¼‰
                const rect = canvas.getBoundingClientRect();
                pinchCenterX = ((e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left) / scale;
                pinchCenterY = ((e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top) / scale;
                
            } else if (e.touches.length === 1) {
                // 1æœ¬æŒ‡ â†’ ãƒ‰ãƒ©ãƒƒã‚°é–‹å§‹
                if (!isPinching) {
                    const touch = e.touches[0];
                    startDrag({ clientX: touch.clientX, clientY: touch.clientY });
                }
            }
        }

        function handleTouchMove(e) {
            e.preventDefault();
            
            if (e.touches.length === 2 && isPinching) {
                // ãƒ”ãƒ³ãƒã‚ºãƒ¼ãƒ ä¸­
                const currentDistance = getDistance(e.touches[0], e.touches[1]);
                const scaleChange = currentDistance / initialPinchDistance;
                const newScale = Math.max(0.1, Math.min(3, initialScale * scaleChange));
                
                // ãƒ”ãƒ³ãƒä¸­å¿ƒãŒç”»é¢ä¸Šã®åŒã˜ä½ç½®ã«ç•™ã¾ã‚‹ã‚ˆã†ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’èª¿æ•´
                // ãƒ¯ãƒ¼ãƒ«ãƒ‰åº§æ¨™ã§ã®ãƒ”ãƒ³ãƒä¸­å¿ƒä½ç½®ã¯å¤‰ã‚ã‚‰ãªã„ãŒã€ã‚¹ã‚±ãƒ¼ãƒ«ãŒå¤‰ã‚ã‚‹ã®ã§
                // ç”»é¢åº§æ¨™ã§ã®ä½ç½®ã‚’ç¶­æŒã™ã‚‹ãŸã‚ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’èª¿æ•´
                const rect = canvas.getBoundingClientRect();
                const currentCenterX = (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left;
                const currentCenterY = (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top;
                
                // æ–°ã—ã„ã‚¹ã‚±ãƒ¼ãƒ«ã§ã®ä½ç½®
                const targetCenterX = currentCenterX / newScale;
                const targetCenterY = currentCenterY / newScale;
                
                // ã‚ªãƒ•ã‚»ãƒƒãƒˆã‚’èª¿æ•´ï¼ˆãƒ”ãƒ³ãƒä¸­å¿ƒãŒå‹•ã‹ãªã„ã‚ˆã†ã«ï¼‰
                offsetX += (targetCenterX - pinchCenterX);
                offsetY += (targetCenterY - pinchCenterY);
                
                pinchCenterX = targetCenterX;
                pinchCenterY = targetCenterY;
                
                scale = newScale;
                
                // ã‚¹ãƒ©ã‚¤ãƒ€ãƒ¼ã‚‚åŒæœŸ
                document.getElementById('zoomSlider').value = scale;
                document.getElementById('zoomValue').textContent = Math.round(scale * 100) + '%';
                
                draw();
                
            } else if (e.touches.length === 1 && !isPinching) {
                // ãƒ‰ãƒ©ãƒƒã‚°ä¸­
                const touch = e.touches[0];
                drag({ clientX: touch.clientX, clientY: touch.clientY });
            }
        }

        function handleTouchEnd(e) {
            e.preventDefault();
            
            if (e.touches.length < 2) {
                isPinching = false;
                initialPinchDistance = 0;
            }
            
            if (e.touches.length === 0) {
                endDrag();
            }
        }

        function getDistance(touch1, touch2) {
            const dx = touch2.clientX - touch1.clientX;
            const dy = touch2.clientY - touch1.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function startDrag(e) {
            isDragging = true;
            lastX = e.clientX;
            lastY = e.clientY;
        }
        
        function drag(e) {
            if (!isDragging) return;
            
            offsetX += (e.clientX - lastX) / scale;
            offsetY += (e.clientY - lastY) / scale;
            
            lastX = e.clientX;
            lastY = e.clientY;
            
            draw();
        }
        
        function endDrag() {
            isDragging = false;
        }
        
        function resetView() {
            setupCanvas();
            fitToScreen();
            draw();
        }
        
        function exportImage() {
            const link = document.createElement('a');
            link.download = 'railplot-layout.png';
            link.href = canvas.toDataURL();
            link.click();
        }
        
        function showStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = type;
            statusDiv.style.display = 'block';
            if (type !== 'loading') {
                setTimeout(() => statusDiv.style.display = 'none', 5000);
            }
        }
    </script>
</body>
</html>
